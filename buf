#include <iostream>
#include <vector>
#include <numeric>

#include <librealsense2/rs.hpp> // RealSense SDK
#include <opencv2/opencv.hpp>   // OpenCV (core, highgui, imgproc, objdetectを含む)
#include "realsense.hpp"

int main() try {
    const int width = 1280;
    const int height = 720;

    // 青色検出のHSV範囲 (H: 80-110, S: 100-255, V: 200-255)
    cv::Scalar lower_red(80, 100, 200);
    cv::Scalar upper_red(110, 255, 255);

    RealsenseOperatorClass realsense(width, height);
    realsense.start_camera();

    while (true) {
        cv::Mat bgr_image;
        realsense.get_image(bgr_image);
        cv::Mat hsv_image;
        cv::cvtColor(bgr_image, hsv_image, cv::COLOR_BGR2HSV);
        
        cv::Mat binary_image;
        cv::inRange(hsv_image, lower_red, upper_red, binary_image);

        std::vector<std::vector<cv::Point>> contours;
        cv::findContours(binary_image, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);

        cv::Mat circle_image = (bgr_image).clone();

        for (const auto& cnt : contours) {
            cv::Point2f center;
            float radius_in_pixel;
            cv::minEnclosingCircle(cnt, center, radius_in_pixel);
            
            float obj_point_3d[3];
            float radius_in_meters;
            realsense.get_point3d_and_length(obj_point_3d, center.x, center.y, radius_in_meters, radius_in_pixel);
            
            if (radius_in_pixel > 30 && obj_point_3d[2] > 0) {
                cv::circle(circle_image, center, static_cast<int>(radius_in_pixel), cv::Scalar(0, 255, 0), 2);

                std::cout << "obj_point_from_origin: ["
                          << obj_point_3d[0] << ", "
                          << obj_point_3d[1] << ", "
                          << obj_point_3d[2] << "], "
                          << "radius: " << radius_in_meters << " meters" << std::endl;
            }
        }
        cv::imshow("Enclosing Circles", circle_image);
        if (cv::waitKey(1) == 'q') break;
    }
    realsense.stop_camera();
    cv::destroyAllWindows();
    return EXIT_SUCCESS;
}
// エラーハンドリング
catch (const rs2::error & e) {
    std::cerr << "RealSense error calling " << e.get_failed_function() << "(" << e.get_failed_args() << "):\n    " << e.what() << std::endl;
    return EXIT_FAILURE;
}
catch (const std::exception& e) {
    std::cerr << e.what() << std::endl;
    return EXIT_FAILURE;
}